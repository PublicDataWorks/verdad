# Stage 1: Detection & Transcription

## Stage 1: Detection & Transcription

Stage 1 serves as the high-recall entry point for the VERDAD pipeline. Its primary objective is to monitor continuous radio broadcasts and efficiently identify segments that potentially contain misinformation or disinformation. By combining rapid multimodal screening with precise automated speech recognition (ASR), this stage filters hours of raw audio into actionable snippets for deeper analysis.

### Overview

The process is divided into two main functional areas:
1.  **Initial Detection:** Uses **Gemini** (1.5 or 2.5 Flash) to perform a rapid "first pass" over the audio. It applies simplified heuristics to identify segments of interest without requiring the full cost of higher-tier models.
2.  **Transcription:** Uses **OpenAI Whisper** to generate detailed, timestamped transcriptions of the identified segments, ensuring that researchers can pinpoint exactly when a claim was made.

---

### Executing the Pipeline

Stage 1 is orchestrated via **Prefect**. In a production environment (such as Fly.io), the pipeline is triggered by setting the `FLY_PROCESS_GROUP` environment variable.

#### Initial Detection
To run the primary detection deployment, which fetches new audio files and processes them:

```bash
# Example: Running the detection worker
export FLY_PROCESS_GROUP="initial_disinformation_detection"
python src/processing_pipeline/main.py
```

**Parameters:**
- `audio_file_id` (Optional): Process a specific file. If `None`, the system fetches the next available file from the queue.
- `limit`: The maximum number of files to process in a single run (Default: `1000`).
- `concurrency_limit`: Maximum simultaneous processing tasks (Default: `100`).

---

### Input and Output Data

#### Input
The pipeline consumes records from the `audio_files` table.
- **Audio File:** 5â€“15 minute segments of radio broadcast.
- **Metadata:** Station code, location, and recorded timestamp.

#### Output
Upon success, Stage 1 generates a record in the `stage_1_llm_responses` table with the following structured data:

| Field | Description |
| :--- | :--- |
| `flagged_timestamps` | Start and end times (in seconds) for suspected snippets. |
| `basic_category` | Initial classification (e.g., Political, Health, Conspiratorial). |
| `confidence_score` | A preliminary score indicating the likelihood of disinformation. |
| `transcript` | The full timestamped text generated by Whisper. |

---

### Safety and Content Moderation

Because the system is designed to analyze potentially harmful content (hate speech, dangerous rhetoric, etc.), the Gemini API safety settings are configured to **BLOCK_NONE**. This ensures the AI does not refuse to analyze a snippet simply because it contains offensive language, which is often the very content journalists need to track.

```python
# Internal safety configuration used during detection
SafetySetting(
    category=HarmCategory.HARM_CATEGORY_HATE_SPEECH,
    threshold=HarmBlockThreshold.BLOCK_NONE,
)
```

---

### Maintenance & Utilities

VERDAD provides several utility flows for managing Stage 1 data without re-running the entire pipeline:

#### Regenerating Transcripts
If a transcription fails or requires a different Whisper model configuration, use the regeneration flow:
- **Deployment Name:** `Stage 1: Regenerate Timestamped Transcript`
- **Use Case:** Updates existing detections with new transcriptions.

#### Redoing Detection
If detection prompts are updated to be more accurate, you can re-run the screening phase:
- **Deployment Name:** `Stage 1: Redo Main Detection Phase`
- **Parameter:** `stage_1_llm_response_ids` (List of IDs to re-evaluate).

#### Undoing Detection
To clear Stage 1 data and reset the audio file status for a fresh start:
- **Deployment Name:** `Stage 1: Undo Disinformation Detection`
- **Parameter:** `audio_file_ids` (List of IDs to revert).

---

### Error Handling
If a file fails during Stage 1, the `audio_file` status is updated to `error` in the database, and the specific error message is logged to the `error_message` column. These are also tracked via **Sentry** for real-time developer alerts.
